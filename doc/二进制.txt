十进制的减法是当前位数不够,向前一位借一(相当于当前位数加10,在进行加减)
例:
				7  4  2  3  3
借一后的数：	6 13 11 13

			-   4  7  5  6  2
		----------------------
结果:			2  6  6  7  1


二进制的减法是当前位数不够,向前一位借一(相当于当前位数加2,在进行加减)

例:
				1  0  1  0  0  1
被接一后的值:	0 -1  0 -1  
借一后的数:		0  1  2  1  2
				
			-	0  1  1  0  1  0
		--------------------------
结果:		    0  0  1  1  1  1
相当于101001-011010=001111(41-26=15)的运算

加法:
	1111+1011 = 11010 (15+11) = 26
	
				1  1  1  1
			+   1  0  1  1
		--------------------
		     1  1  0  1  0
			 
二进制运算符:
& (与运算 and) : 全1为1, 有0为0;
例: 
	1101 & 1001 = 1001

| (或运算 or)  : 有1为1, 全0为0;
例:
	1101 | 1001 = 1101

^ (异或)       : 同为0，异为1;
例:
	1101 ^ 1001 = 0100

	
	
	
原码，反码，补码:

一、原码就是早期用来表示数字的一种方式: 一个正数，转换为二进制位就是这个正数的原码。负数的绝对值转换成二进制位然后在高位补1就是这个负数的原码.
举例说明：
		int类型的 3 的原码是 11B(B表示二进制位),在32位机器上占四个字节,那么高位补零就得: 00000000 00000000 00000000 00000011.
		int类型的 -3 的绝对值的二进制位就是上面的 11B 展开后高位补零就得: 10000000 00000000 00000000 00000011.
		　　　　　
但是原码有几个缺点,零分两种 +0 和 -0.很奇怪是吧!还有在进行不同符号的加法运算或者同符号的减法运算的时候,不能直接判断出结果的正负.
你需要将两个值的绝对值进行比较,然后进行加减操作,最后符号位由绝对值大的决定。于是反码就产生了.

二、正数的反码就是原码(也可以理解为正数的反码就是其本身)，负数的反码等于原码除符号位以外所有的位取反.
举例说明：
		int类型的 3 的反码是: 00000000 00000000 00000000 00000011 .(和原码一样没什么可说的)
		int类型的-3 的反码是: 11111111 11111111 11111111 11111100  (除开符号位, 所有位取反)

		
负数以其正数的补码形式表示！(负数要以补码的形式存储)
以-14为例，来简单阐述一下原码、反码和补码。
原 码
一个整数按照绝对值大小转化成的二进制数称为原码
例如：00000000 00000000 00000000 00001110 是14的原码。
反 码
将二进制数按位取反，所得到的新二进制数称为原二进制数的反码。
例如：将00000000 00000000 00000000 00001110 每一位取反，
得11111111 11111111 11111111 11110001
注意：这两者互为反码
补 码
反码加1称为补码
11111111 11111111 11111111 11110001 +1 = 11111111 11111111 11111111 11110010
现在我们得到-14的二进制表示，现在将它左移
-14（11111111 11111111 11111111 11110010）<<2 = 11111111 11111111 11111111 11001000 =？

分析：这个二进制的首位为1，说明是补码形式，现在我们要将补码转换为原码（它的正值）跟原码转换为补码相反，将补码转换为原码的步骤：
补码减1得到反码: (11000111)前24位为1,此处省略,反码取反得到原码（即该负数的正值）(00111000),计算正值，正值为56,取正值的相反数，得到结果-56
结论：-14<<2 = -56反码

负数为补码形式
步骤一: 取反码(补码减1得到反码)
11111111 11111111 11111111 11001000 - 1 = 11111111 11111111 11111111 11000111.
步骤二: 取原码(绝对值) (反码取反得到原码)
11111111 11111111 11111111 11000111(取反) 00000000 00000000 00000000 00111000 = 2^5 + 2^4 + 2^3 = 32 + 16 + 8 = 56.
步骤三: 取相反数(取绝对值值的相反数)
-56.


-1 绝对值原码
00000000 00000000 00000000 00000001
-1 反码
11111111 11111111 11111111 11111110
-1补码
11111111 11111111 11111111 11111110 + 1 = 11111111 11111111 11111111 11111111

-1 + 1;
11111111 11111111 11111111 11111111 + 00000000 00000000 00000000 00000001 = 00000000 00000000 00000000 00000000 00000000

-2 绝对值原码
00000000 00000000 00000000 00000010
-1 反码
11111111 11111111 11111111 11111101
-1补码
11111111 11111111 11111111 11111101 + 1 = 11111111 11111111 11111111 11111110

-2 + 1;
11111111 11111111 11111111 11111110 + 00000000 00000000 00000000 00000001 = 11111111 11111111 11111111 11111111

以1开头 为负数(补码)
11111111 11111111 11111111 11111111

反码 : 11111111 11111111 11111111 11111111 - 1 = 11111111 11111111 11111111 11111110
原码 : 11111111 11111111 11111111 11111110 --> 00000000 00000000 00000000 00000001 = 1
相反数(结果) : -1


三、正数的补码与原码相同,负数的补码为其原码除符号位外所有位取反(得到反码了),然后最低位加1.
举例说明：
		int类型的 3 的补码是：00000000 00000000 00000000 00000011
		int类型的-3 的补码是: 11111111 11111111 1111111 11111101(就是其反码加1)

总结：
	正数的反码和补码都与原码相同。
	负数的反码为对该数的原码除符号位外各位取反。
	负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1　　

各自的优缺点：
	原码最好理解了，但是加减法不够方便，还有两个零。。
	反码稍微困难一些，解决了加减法的问题，但还是有有个零
	补码理解困难，其他就没什么缺点了

	
(对于正数而言，>>和>>>没区别)
<<(向左位移): 针对二进制,转换成二进制后向左移动3位,后面用0补齐.  
>>(向右位移): 针对二进制,转换成二进制后向右移动3位.  
>>> 表示无符号右移,也叫逻辑右移: 即若该数为正,则高位补0,而若该数为负数,则右移后高位同样补0.  (>>> 不考虑高位的正负号，正数的 >>> 等同于 >>)

16 << 1;(左移1位)  (<< 1  相当于乘以2)
00010000
00100000

16>>1;(右移一位)   (>> 1  相当于除以2)
00010000
00001000

-14>>>2
(11111111 11111111 11111111 11110010)>>>2 =(00111111 11111111 11111111 11111100)=1073741820


-----------------------------------------
&和%%的异同:
相同点: 都是逻辑运算符：当判断条件两边都为true是，条件为true

不同点: 
1.&不管第一个条件是否为false,第二个条件都会运行,两边同时为true输出结果.
2.&&只要第一个条件为false后面的条件就不会执行了.
3.&可以做二进制的运算,同为1则为1,其他为0.

|和||的异同点

相同点：逻辑运算,两边条件都为false,才为false,其他都是true.
不同点：
1.与上同
2.|做二进制运算时,同时为0才为0,其他为1.
